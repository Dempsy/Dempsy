{"name":"Dempsy","body":"# Project\r\n\r\nWelcome to the Dempsy project - a framework for the easy implementation of stream-based real-time map-reduce applications.\r\n\r\n## Documentation\r\n\r\nSee the [Dempsy User Guide](https://github.com/Dempsy/Dempsy/wiki/User-Guide).\r\n\r\nSince we are updating the documentation frequently, we recommend that you watch the [Documentation issue](https://github.com/Dempsy/Dempsy/issues/23) (at the bottom of the issue page click on \"Enable notifications for this issue\")  \r\n\r\nIf you prefer, you can go straight to the initial tutorial \"[Simple Example](https://github.com/Dempsy/Dempsy/wiki/Simple-Example)\"\r\n\r\nThe [Dempsy Examples](https://github.com/Dempsy/Dempsy-examples) repository has several versions of the WordCount example. When reading through the \"[Simple Example](https://github.com/Dempsy/Dempsy/wiki/Simple-Example)\" you'll want to be viewing the code in the [userguide-wordcount](https://github.com/Dempsy/Dempsy-examples/tree/master/userguide-wordcount) sub-project.\r\n\r\nDempsy recognizes three types of developers and the api documentation is organized accordingly.\r\n\r\n<table>\r\n<tr>\r\n<th> Developer </th><th> Description </th><th>Api Documentation</th>\r\n</tr>\r\n<tr>\r\n<td>Application Developer</td><td>Developers that are going to build real-time stream based analytics fall into this category.</td><td><a href=\"http://dempsy.net/appdev-apidocs/\">Application Developer Api Documentation</a></td>\r\n</tr>\r\n<tr>\r\n<td>Framework Developer</td><td>Dempsy is built on a set of abstractions that allow it to be extended with new transports, routing strategies, monitoring techniques, as well as others. Developers interested in adding new implementations or techniques fall into this category. This Api extends the Applicaiton Developer Api above.</td><td><a href=\"http://dempsy.net/core-apidocs/\">Framework Developer Api Documentation</a></td>\r\n</tr>\r\n<tr>\r\n<td>Dempsy Contributors</td><td>Any developer changing the existing framework or any of the default implementations of the core abstractions will need the complete Api documentation for the entire codebase.</td><td><a href=\"http://dempsy.net/all-apidocs/\">Framework Developer Api Documentation</a></td>\r\n</tr>\r\n</table>\r\n\r\nThis Api documentation is currently for the 0.6-SNAPSHOT revision.\r\n\r\n\r\n## Download\r\n\r\nDempsy is currently releases as a set of libraries and version 0.6 is now in the Maven Central Repository so you can build against released Dempsy code directly.\r\n\r\nTo build an application against Dempsy you will need to add the Dempsy dependencies to your build. This should be as simple as including the following dependency in your maven ```pom.xml``` file (or the gradle equivalent).\r\n\r\n```xml\r\n<dependency>\r\n   <groupId>net.dempsy</groupId>\r\n   <artifactId>lib-dempsyspring</artifactId>\r\n   <version>0.6</version> <!-- Current version -->\r\n</dependency>\r\n```\r\n\r\nPlease review the section on [Understanding the Dempsy Codebase](https://github.com/Dempsy/Dempsy/wiki/Codebase) for an overview of how the library jar files are organized.\r\n\r\nYou can download the source code by cloning the GitHub repository\r\n\r\n```bash\r\ngit clone git://github.com/Dempsy/Dempsy.git\r\n```\r\n\r\nor you can download a released version of the sourcecode:\r\n\r\n1. Zip file: [Dempsy version 0.6 zip](https://github.com/Dempsy/Dempsy/zipball/dempsy-parent-0.6)\r\n1. Tar and gzipped: [Dempsy version 0.6 tar.gz](https://github.com/Dempsy/Dempsy/tarball/dempsy-parent-0.6)\r\n\r\n## Current Work\r\n\r\nSee the [issues](https://github.com/Dempsy/Dempsy/issues) list for a backlog. The primary tasks are currently:\r\n\r\n1. Full Elasticity - While Dempsy was built from the ground up to be elastic, the ability for the topology to dynamically morph is under development and expected in May.\r\n1. AWS push button deployment and an example integration with an elastic provisioning tool\r\n\r\n## Getting Help\r\n\r\nThe team is available through several channels.\r\n\r\n* If you have a specific issue like a bug report or feature request, you can use the [issues](https://github.com/Dempsy/Dempsy/issues) list.\r\n* Comment on any discussion on any [issues](https://github.com/Dempsy/Dempsy/issues), [commit](https://github.com/Dempsy/Dempsy/commits/master), or [Pull Request](https://github.com/Dempsy/Dempsy/pulls) \r\n* You can subscribe to the [Dempsy Email Group](http://tech.groups.yahoo.com/group/DempsyUser/)\r\n* You can join the IRC chanel and see if we're in. It's at [FreeNode.net](http://freenode.net/faq.shtml) IRC. The channel is ```#dempsy```. Currently it's best to catch us during the day in the Eastern US.\r\n\r\n# Overview\r\n\r\n* See the recent [InfoQ post](http://www.infoq.com/news/2012/04/Dempsy) on Dempsy\r\n\r\n## What is Dempsy?\r\n\r\nIn a nutshell, Dempsy is a framework that provides for the easy implementation Stream-based, Real-time, BigData applications.\r\n\r\nDempsy is the Nokia's \"Distributed Elastic Message Processing System.\"\r\n\r\n* Dempsy is _Distributed_. That is to say a dempsy application can run on multiple JVMs on multiple physical machines.\r\n* Dempsy is _Elastic_. That is, it is relatively simple to scale an application to more (or fewer) nodes. This does not require code or configuration changes but allows the dynamic insertion and removal of processing nodes.\r\n* Dempsy is _Message Processing_. Dempsy fundamentally works by message passing. It moves messages between Message processors, which act on the messages to perform simple atomic operations such as enrichment, transformation, or other processing. Generally an application is intended to be broken down into more smaller simpler processors rather than fewer large complex processors.\r\n* Dempsy is a _Framework_. It is not an application container like a J2EE container, nor a simple library. Instead, like the [Spring Framework](http://www.springsource.org) it is a collection of patterns, the libraries to enable those patterns, and the interfaces one must implement to use those libraries to implement the patterns.\r\n\r\n## What Problem is Dempsy solving?\r\n\r\nDempsy is not designed to be a general purpose framework, but is intended to solve a certain class of problems while encouraging the use of the best software development practices.\r\n\r\nDempsy is meant to solve the problem of processing large amounts of \"near real time\" stream data with the lowest lag possible; problems where latency is more important that \"guaranteed delivery.\" This class of problems includes use cases such as:\r\n\r\n* Real time monitoring of large distributed systems\r\n* Processing complete rich streams of social networking data\r\n* Real time analytics on log information generated from widely distributed systems\r\n* Statistical analytics on real-time vehicle traffic information on a global basis\r\n\r\nIt is meant to provide developers with a tool that allows them to solve these problems in a simple straightforward manner by allowing them to concentrate on the analytics themselves rather than the infrastructure. Dempsy heavily emphasizes \"separation of concerns\" through \"dependency injection\" and out of the box supports both Spring and Guice. It does all of this by supporting what can be (almost) described as a \"distributed actor model.\"\r\n\r\nIn short Dempsy is a framework to enable decomposing a large class of message processing applications into flows of messages to relatively simple processing units implemented as [POJOs](http://en.wikipedia.org/wiki/Plain_Old_Java_Object)\r\n\r\n### Features\r\n\r\nImportant features of Dempsy include:\r\n\r\n* Built to support an “inversion of control” programming paradigm, making it extremely easy to use, and resulting in smaller and easier to test application codebases, reducing the total cost of ownership of applications that employ Dempsy.\r\n* Fine grained message processing allows the developer to decompose complex analytics into simple small steps. \r\n* Invisible Scalability. While Dempsy is completely horizontally scalable and multithreaded, the development paradigm supported by Dempsy removes all scalability and threading concerns from the application developer. \r\n* Dynamic topologies. There is no need to hard wire application stages into a configuration or into the code. Topologies (by default) are discovered at run-time.\r\n* Full elasticity (for May). Dempsy can handle the dynamic provisioning and decommissioning of computational resources.\r\n\r\nDempsy is intentionally not an “Application Server” and runs in a completely distributed manner relying on Apache ZooKeeper for coordination. In sticking with one of the development teams guiding principles, it doesn’t try to solve problems well solved in other parts of the industry. As DevOps tools become the norm in cloud computing environments, where it’s “easier to re-provision that to repair,” Dempsy defers to such systems the management of computational resources, however, being fully elastic (May 2012), it cooperates to produce true dynamic fault tolerance.\r\n\r\n### What is a Distributed Actor Framework?\r\n\r\nDempsy has been described as a distributed actor framework. While not strictly speaking an [actor](http://en.wikipedia.org/wiki/Actor_model) framework in the sense of [Erlang](http://www.erlang.org) or [Akka](http://akka.io) actors, in that actors typically direct messages directly to other actors, the Message Processors in Dempsy are \"actor like POJOs\" similar to Processor Elements in [S4](http://s4.io) and less so like Bolts in [Storm](https://github.com/nathanmarz/storm). Message processors are similar to actors in that Message processors act on a single message at a time, and need not deal with concurrency directly. Unlike actors, Message Processors also are relieved of the the need to know the destination(s) for their output messages, as this is handled inside Dempsy itself.\r\n\r\nThe Actor model is an approach to concurrent programming that has the following features:\r\n\r\n* **Fine-grained processing**\r\n\r\nA traditional (linear) programming model processes input sequentially, maintaining whatever state is needed to represent the entire input space. In an \"Fine Grained Actor\" model, input is divided into messages and distributed to a large number of independent actors. An individual actor maintains only the state needed to process the messages that it receives.\r\n\r\n* **Shared-Nothing**\r\n\r\nEach actor maintains its own state, and does not expose that state to any other actor. This eliminates concurrency bottlenecks and the potential for deadlocks. Immutable state may be shared between actors.\r\n\r\n* **Message-Passing**\r\n\r\nActors communicate by sending immutable messages to one-another. Each message has a key, and the framework is responsible for directing the message to the actor responsible for that key.\r\n\r\nA distributed actor model takes an additional step, of allowing actors to exist on multiple nodes in a cluster, and supporting communication of messages between nodes. It adds the following complexities to the Actor model:\r\n\r\n* **Distribution of Messages**\r\n\r\nA message may or may not be consumed by an actor residing in the same JVM as the actor that sent the message. The required network communication will add delay to processing, and require physical network configuration to support bandwidth requirements and minimize impact to other consumers.\r\n\r\n* **Load-Balancing**\r\n\r\nThe framework must distribute work evenly between nodes, potentially using different strategies for different message types (eg: regional grouping for map-matcher, simple round-robin for vehicles).\r\n\r\n* **Node Failure**\r\n\r\nIf a node fails, the workload on that node must be shifted to other nodes. All state maintained by actors on the failed node is presumed lost.\r\n\r\n* **Network Partition**\r\n\r\nIf the network connection to a node temporarily drops, it will appear as a node failure to other nodes in the cluster. The node must itself recognize that it is no longer part of the cluster, and its actors must stop sending messages (which may conflict with those sent by the cluster's \"replacement\" node).\r\n\r\n* **Node Addition**\r\n\r\nTo support elastic scalability (adding nodes on demand to service load, as well as re-integration of a previously failed node), the framework must support redistribution of actors _and their state_ based on changes to the cluster.\r\n\r\n## Guiding philosophy\r\n\r\nAbove all, and in many ways, Dempsy is meant to be *SIMPLE*. It doesn't try to be the solution for every problem. It tries to do one thing well and it is meant to support developers that think this way. Dempsy is built emphasizing, and built to emphasize several interrelated principles. These principles are meant to reduce the longer term total cost of ownership of the software written using Dempsy. These include:\r\n\r\n* Separation of Concerns (SoC) - Dempsy expects the developer to be able to concentrate on writing the analytics and business logic with (virtually) no consideration for framework or infrastructure.\r\n\r\n* Decoupling - SoC provides the means to isolate cross-cutting concerns so that code written for Dempsy will have little to no (with due respect to annotations) dependence on even the framework itself. Developer's code can be easily run separate from the framework and, in the spirit of Dependency Injection, the framework uses the developer's code rather than the developer having to use the framework. This type of decoupling provides for analytics/business code that has no infrastructure concerns: no framework dependencies, no messaging code, no threading code, etc.\r\n\r\n* Testability - All of this provides a basis to write code that's more testable.\r\n\r\n* \"Do one thing well\" - Dempsy is written to provide one service: support for the type of \"Distributed Actor Model\" (with all of the acknowledged caveats) programming paradigm. For this reason it does not pretend to be an Application Server. Nor does it substitute for the lack of an automated provistioning/deployment system. \r\n\r\n## What about other options?\r\n\r\n#### Complex Event Processing systems (CEP)\r\n\r\nCEP is really trying to solve a different problem. If you have a large stream of data you want to mine by separating it into subsets and executing different analytics on each subset (which can including ignoring entire subsets), then CEP solutions make sense. If, however, you’re going to do the same thing to every message then you will be underutilizing the power of CEP. Underutilized functionality usually means an increased total cost of ownership, and Dempsy is ALL ABOUT reducing the total cost of ownership for systems that do this type of processing.\r\n\r\n#### Pure Actor Model Frameworks and Languages\r\n\r\nThere are several pure [\"Actor Model\"](http://en.wikipedia.org/wiki/Actor_model) frameworks and languages that have been posed as alternatives for Dempsy. Dempsy is not a pure actor model and primarily solves a different problem. As described above Dempsy is primarily a routing mechanism for messages for \"fine grained\" actors. The reason we still (though loosely) call it an \"actor model\" is because Dempsy supports concurrency the way a typical Actor Model does.\r\n\r\n#### Other Stream Processors\r\n\r\nDempsy emphasizes reducing the total cost of ownership of real-time analytics applications and as a direct result we feel it has some advantages over the alternatives.\r\n\r\nFirst, as mentioned, Dempsy supports “fine grained” message processing. Because of this, by writing parallel use-cases in Dempsy and alternatives that don't support this programming model, we find that Dempsy leads to a lower code-line count.\r\n\r\nAlso, because of Dempsy’s emphasis on “Inversion of Control” the resulting applications are more easily testable. With the exception of annotations, Message Processors, which are the atomic unit of work in Dempsy, have no dependency on the framework itself. Every alternative we've found requires that the application be written against and written to use that framework.\r\n\r\nAlso, in following the adage to never require the system to be told something that it can deduce, the topology of a Dempsy application’s pipeline is discovered at runtime and doesn’t need to be preconfigured. This is primarily a by-product of the fact that Dempsy was designed from the ground up to be “elastic” and as a result, the topology can morph dynamically.\r\n\r\nThis means that applications with complicated topologies with many branches and merges can be trivially configured since the dependency relationship between stages is discovered by the framework.\r\n\r\n## Now that you've decided to give it a try\r\n\r\n* See \"[The Dempsy User Guide](https://github.com/Dempsy/Dempsy/wiki/User-Guide)\" and the \"[Simple Example](https://github.com/Dempsy/Dempsy/wiki/Simple-Example)\" to get a better idea of what it can do.","tagline":"Distributed Elastic Message Processing System","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}